<!DOCTYPE html>
<html lang="es">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Java - Unit 1/6</title>
		<!-- Bootstrap -->
		<link href="../css/bootstrap.min.css" rel="stylesheet">
		<link href="../css/styles.css?v=1.2" rel="stylesheet">
		<link href="../css/queries.css?v=1.2" rel="stylesheet">
		<link rel="stylesheet" href="../css/flexslider.css?v=1.2" type="text/css">
		<link rel="stylesheet" href="../css/animate.css" type="text/css">
		<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
		<link rel="shortcut icon" href="../img/main-logo.webp" type="image/x-icon">
		<!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
		<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
		<!--[if lt IE 9]>
		<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
		<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
		<![endif]-->
	</head>
	<body>
		<header>
			<div class="container">
				<div class="row">
					<div class="responsive-logo"></div>
					<div class="pullcontainer">
						<a href="#" id="pull"><i class="fa fa-bars fa-2x"></i></a>
					</div>
				</div>
				<div class="row">
					<div class="col-md-8 col-md-offset-2">
						<nav>
							<div class="logo-holder"></div>
							<ul class="clearfix">
								<li><a href="index.html">Home</a></li>
								<li class="dot">.</li>
								<li><a href="java.html" class="r_spacer">Co. Java</a></li>
								<li><a href="intellij.html">Co. IntelliJ</a></li>
								<li class="dot">.</li>
								<li><a href="vs.html">Co. VS</a></li>
							</ul>
						</nav>
					</div>
				</div>
			</div>
			<div class="hero"></div>
		</header>
		<div class="container-fluid intro" id="about">
			<div class="row">
				<div class="col-md-8 col-md-offset-2">
					<hr>
					<h1 class="chain">Java básico. - Los conceptos claves que necesitas aprender.</h1>
					<p>
						<!-- Qué es un objeto. -->
						<h2>¿Qué es un objeto?</h2>
						<p>
							<hr>
							Un objeto en Java no es más ni menos que lo mismo que un objeto en el mundo real. No tiene existencia física (en el sentido de que no puedes tocarlo como puedes tocar una lámpara), pero sí existe como 'algo' 
							que contiene información sobre sí mismo y sobre su estado, y con el que puedes interactuar. <br>
							Por ejemplo, <i>la lámpara de la que hablamos. Es blanca y tiene un botón de encendido y apagado. Supongamos que está encendida.</i> <br>
							Ahora, imagínate otra lámpara, igual que la anterior, que está a su lado. La única diferencia es que ésta es azul. Y está apagada. <br>							
							Pues bien: si queremos crear un objeto de tipo <i>Lámpara</i> en Java, primero debemos crear un molde, donde vamos a especificar el comportamiento del objeto (cómo apagar y encender la lámpara), así como sus
							características (el color de la lámpara). Utilizando este molde podremos producir tantos objetos de tipo <i>Lámpara</i> como lo permita  la memoria del dispositivo. A este molde se e denomina <b>clase</b> en Java. <br>
							Una clase en Java es un molde, que permite crear un número ilimitado de objetos.
						</p>
						<!-- Propiedades de las clases. -->
						<h2>Propiedades de las clases</h2>
						<p>
							<ol>
								<li>Un archivo <b>.java</b> puede contener un número ilimitado de clases.</li>
								<li>De ese número ilimitado, solo una clase puede ser <i>public</i>. La <b>clase pública</b> ha de llamarse igual que el archivo que la contiene.</li>
								<li>Una clase, sin ser pública, puede llamarse igual que en el archivo que la contiene.</li>
								<li><b>No deben repertirse nombres</b> Cada clase ha de tener su propio nombre, distinto de los demás.</li>
							</ol>
							Empezamos creando la clase <b>Lampara</b>. 
							<code>
								<pre>
package net.humancomputing;

public class Lampara {
	// Aquí el molde para crear las lámparas.

}
class LamparaCreator {
	public static void main (String[] args) {
		// En esta clase se van a crear las lámparas.

	}
}
								</pre>
							</code>
							Como se puede apreciar, en un mismo archivo:
							<ol type="bullet">
								<li>Puede contener varias clases.</li>
								<li>No es obligatorio que contenga una clase pública</li>
								<li>Y, por último, una clase puede llamarse igual que el archivo que la contiene, sin ser pública.</li>
							</ol>
						</p>
						<!-- Crear e instanciar un objeto en Java. -->
						<h2>Cómo crear o instanciar un objeto en Java.</h2>
						<p>
							Una vez que se ha creado la clase, ya puede crear o instanciar un objeto en Java. La <i>frase mágica</i> para instanciar un objeto contiene las siguientes partes: 
							<code>
								<pre>
Lampara lampara = new Lampara();									
								</pre>
							</code>
							<ol>
								<li>En primer lugar, especificamos el tipo de objeto que estamos creando. Dicho de otro modo, especificamos qué clase estamos instanciando. Aquí, <b>Lampara</b>.</li>
								<li>A continuación, la referencia al objeto, es decir, el nombre del objeto.</li>
								<li>La palabra clave <i>new</i> (nuevo), que es la que se encarga de instanciar el objeto.</li>
								<li>De nuevo, el tipo de la clase y un paréntesis.</li>
								<li>El paréntesis se usa para introducir parámetros que sean necesarios para crear el objeto. Por ejemplo, si quiero crear una lámpara rosa, podría ser la palabra 'rosa'. 
									Pero, para ello, debo de tener en la clase <b>Lampara</b> un constructor que acepte un parámetro de tipo String (texto entrecomillado). En nuestro ejemplo aún no lo tenemos, 
									de manera que instanciar un objeto de tipo <b>Lampara</b> con parámetros no va a compilar.
								</li>
							</ol>
							Antes de continuar, ten en cuenga en cuenta que esta referencia no es el objeto, sino que <b>apunta al objeto</b>. Podemos tener varias referencias apuntando al mismo objeto, por ejemplo:
							Mi perro se llama 'Katan' pero dependiendo de la situación o la persona lo pueden llamar  de maneras diferentes, pueden ser <b>'el consentido de casa'</b>, 'perro', 'el labrador', 'can', 
							<s>'chucho'</s> o 'cachorro', por ejemplo. Todas esas referencias apuntan a un mismo objeto 'mi perro que se llama Katan'.
						</p>
						<!-- Diferencias entre objeto y referencia. -->
						<h2>Diferencias entre objeto y referencia.</h2>
						<p>
							En <b>Java</b> no tienes nunca acceso al objeto en sí, siempre vas a operar usando la referencia. Cuando un objeto se queda sin referencias que apunten a él (porque todas éstas apuntan a <i>null</i>
							o a otro objeto), Java termina borrándolo de la memoria.
							<ul>
								<li>
									El signo = asigna a la referencia el objeto que creamos. Es decir, que es como decir esta referencia apunta a este objeto. En Java, este signo no significa 'igual', sino que se usa para asignar 
									un valor, en este caso, una referencia.
								</li>
								<li>
									El signo para expresar igualdad es ==. No obstante, se usa para comparar dos referencias, lo que está haciendo  es comparando si ambas apuntan al mismo objeto o no, no está comparando la igualdad
									de los objetos a los que apuntan.
								</li>
							</ul>
							Puede asignarle a una referencia otro objeto ya creado, o null. <b>Null</b> significa que la referencia no apunta a ninguna parte. Es una etiqueta en el suelo, una vez ya arrancada.
							<code>
								<pre>
Lampara lampara = new Lampara();
Lampara lampara2 = new Lampara();
Lampara lampara3 = lampara; 
lampara = null;									
								</pre>
							</code>
							<h3>¿Cuántos objetos de tipo <strong>Lampara</strong> se han creado?</h3>
							<p>
								En realidad, solo dos. 
								Una <b>lampara</b> y <strong>lampara3</strong> apuntan al mismo objeto; hasta la última línea, donde a <b>lampara</b> se le asigna el valor null (es decir, que no apunte a ningún objeto).
							</p>
							<h3>Siguiendo con el ejemplo de Katan...</h3>
							<p>
								... tendríamos a un perro que lo llamamos 'cachorro', ya que tiene 1 mesesito. <br>
								Al tiempo, le adopto y le llama 'Katan'. A continuación, decido llevarlo a casa de la familia 
								y a 'cachorro' lo vamos a llamar también 'el consentido de casa'. Así que tendríamos tres nombres ('cachorro', 'Katan' y 'el consentido de casa') que apuntan al mismo perro.
								Al asignar el valor null a la primera asignación, tenemos que al perro ya sólo se le conocerá por 'Katan' o 'el consentido de casa'. <br>
								Ya 'cachorro' deja de ser un nombre que haga referencia a el perro.
							</p>
							<h3>En resumen</h3>
							<p>
								<ul>
									<li>
										Una clase es un 'molde' para crear infinidad de objetos.
									</li>
									<li>
										Ub objeto en Java, al igual que un objeto real, puede tener un comportamiento y características propias.
									</li>
									<li>
										Cuando opera con un objeto en realidad lo hace a través de una referencia que apunta a dicho objeto, no con el objeto en sí. Recuerda, es como cuando usas el nombre 'Katan' para referirte a mi perro.
									</li>
								</ul>
								Vamos a hacer un pequeño código a continuación. 
								<code>
									<pre>
package net.humancomputing;
public class Lampara { }
class LamparaCreator { 
	public static void main(String[] args) {
		Lampara lampara = new Lampara();     // -> Crea una 'lampara'
		Lampara lampara1 = new Lampara();    // -> Crea una 'lampara1'
		lampara = null;                      // -> 'lampara' es null -> Desaparece
		Lampara lampara2 = new Lampara();    // -> Crea una 'lampara2'
		Lampara lampara3 = lampara;          // -> Crea una 'lampara3' = a 'lampara' y 'lampara' es null, entonces 'lampara3' no existe tampoco, es null también.
		lampara1 = lampara2;                 // -> Copiamos la 'lampara2' en la 'lampara1', ya son iguales!
		lampara = new Lampara();             // -> Crea una nueva 'lampara' 
		lampara3 = lampara2;                  // -> Copiamos en 'lampara2' en la 'lampara3', ya son iguales! 
	}
}										
									</pre>
								</code>
							</p>
						</p>
						<!-- Que es un constructor. -->
						<h2>¿Qué es un constructor?</h2>
						<p>
							<h3>¿Qué diferencia hay entre un método y un constructor en Java?</h3>
							<p>
								Aunque son similares, tanto la función de un método como su signatura son diferentes a los de un constructor. Retomando el ejemplo de la lámpara. La clase <strong>Lampara</strong>.
								<code>
									<pre>
package net.humancomputing;
public class Lampara {
	private String color; 
	public void Lampara (String color) {
		this.color = color;
	}
}							
class LamparaCreator {
	public static void main(String[] args) {
		Lampara lampara = new Lampara("roja");
	}
}			
									</pre>
								</code>
								Al ejecutar el anterior código, <strong>Lampara(String color)</strong> es un método y no un constructor. <br>
								<h4>¿Cuál es la diferencia?</h4>
								<p>
									<strong>Un constructor en Java nunca especifica un valor de devolución.</strong> Como puede ver, en el método del ejemplo se especifica <i>void</i>. Pues el hecho de que un método pueda tener el mismo 
									nombre que la clase que lo contiene puede dar lugar a confusión. No es códigobien escrito, por confuso, pero es válido.
								</p>
								<h4>¿Qué es un constructor explícito?</h4>
								<p>
									Quizá recuerde que en la lección anterior se planteó, como ejercicio, ver cuántos objetos se creaban en el código que se mostraba. Es posible que vieras que, aunque todo compilaba perfectamente, no había ningún 
									constructor a la vista. Esto se debe a que una clase en Java siempre ha de tener un constructor. Así, sí tú no lo creas de manera explícita, la clase crea un constructor implícito, que ni acepta parámetros no realiza otra 
									función más que la de instanciar los objetos. Una clase sin constructor es, pues, igual que una clase con el siguiente constructor:
									<code>
										<pre>
package net.humancomputing;

public class Lampara {
	public Lampara() { }
}
										</pre>
									</code>
									Ten en cuenta que, en cuanto una clase contiene un constructor en Java, el constructor implícito deja de existir. Es decir, si el constructor de la clase <b>Lampara</b> tiene un parámetro, ya no podremos instanciar un objeto de tipo 
									Lampara sin ningún parámetro, a no ser que creemos otro constructor que no acepte parámetros. 
									<code>
										<pre>
package net.humancomputing;

public class Lampara {
	private String color;
	public Lampara(String color) { 
		this.color = color;
	}
}							

class LamparaCreator {
	public static void main(String[] args) {
		Lampara lampara = new Lampara();
	}
}
										</pre>
									</code>
									La clase con dos constructores compila y se ejecuta.
								</p>
								<h4>¿Cuántos constructores puede tener una clase?</h4>
								<p>
									El número de constructores que puede contener una clase Java es ilimitado, siempre y cuando su signatura<a href="https://es.wikipedia.org/wiki/Signatura_(inform%C3%A1tica)" target="_blank" rel="noopener noreferrer">*</a> sea distinta.
									Es decir, han de ser constructores <b>sobrecargados</b>, que acepten distintos parámetros. Ejemplos:
									<code> Ej.1
										<pre>
package net.humancomputing;

public class Lampara {
	private String color;
	public Lampara(String color) { 
		this.color = color;
	}

	public Lampara() { }
}							

class LamparaCreator {
	public static void main(String[] args) {
		Lampara lampara1 = new Lampara();
		Lampara lampara2 = new Lampara("Azul");
	}
}
										</pre>
									</code>
									En el caso del primer objeto instanciado, <b>lampara1</b>, la variable <b>color</b> toma el valor predeterminado que, en este caso (al ser String un objeto) es <b>null</b>.
								</p>
								<h4>Constructores en cascada</h4>
								<p>
									En este otro caso, coexisten varios varios constructores al igual que en el caso anterior, pero cada uno requiere un parámetro más que el anterior. Así, si instancas un objeto con el menor 
									número de parámetros posible, cada constructor va a inicializar una variable por sí mismo y va a enviar al siguiente constructor las variables ya inicializadas mediante la palabra clave <b>this()</b>.
									<code>
										Ej.2
										<pre>
package net.humancomputing;

public class Lampara {
	private String color;
	private boolean encendida;
	
	public Lampara() {
		this("gris");
	}
	public Lampara(String color) {
		this(color, true);
	}
	public Lampara(String color, boolean estaEncendida) {
		this.color = color;
		this.encendida = estaEncendida;
	}

	@Override 
	public String toString() {
		return "La lampara es " + color + " y está encendida: " + encendida;
	}
}											
class LamparaCreator {
	public static void main (String[] args) {
		Lampara lampara1 = new Lampara();
		Lampara lampara2 = new Lampara("Blanca");
		Lampara lampara3 = new Lampara("Azul", false);

		System.out.println(lampara1);  // -> Lampara 1 es gris y está encendida: true.
		System.out.println(lampara2);  // -> Lampara 2 es Blanca y está encendida: true.
		System.out.println(lampara3);  // -> Lampara 3 es Azul y está encendida: false.
	}
}
										</pre>
									</code>
									Cada vez que se ha instanciado un objeto de tipo Lampara, se ha introducido un parámetro nuevo. En el primer objeto se han usado los tres constructores; en el segundo, solo dos, en el último, solo un constructor.
								</p>
								<h4>¿Qué es this() y cómo usarlo?</h4>
								<p>
									Se uso <b>this()</b> para pasar de un constructor a otro los parámetros necesarios. Lo único que tiene que saber es que <b>this()</b>, si se usa, siempre ha de ser la primera línea dentro del constructor. <br>
									El constructor puede contener más código, pero this() ha de estar siempre en primer lugar. Además, this() solo se puede usar en un constructor, no en un método.
								</p>
								<h4>¿Si en lugar de this(), uso 'new' para instanciar un objeto usando el otro constructor?</h4>
								<p>
									Veamolo con un ejemplo. 
									<code>
										<pre>
package net.humancomputing;

public class Lampara { 
	private String color;
	private boolean encendida; 

	public Lampara(String color, boolean encendida) {
		this.color = color;
		this.encendida = encendida;
	}

	public Lampara(boolean encendida, String color) {
		this.color = color;
		this.encendida = encendida;
	}

	@Override
	public String toString() {
		return "Lampara es de color: " + color + " y está encendida: " + encendida;
	}
}										

class LamparaCreator {
	public static void main(String[] args) {
		Lampara lampara1 = new Lampara(true, "Amarilla");
		Lampara lampara2 = new Lampara("Verde", false);

		System.out.println(lampara1);
		System.out.println(lampara2);
	}
}
										</pre>
									</code>
									El resultado es muy distinto al anterior, al usar <b>new Lampara()</b>, lo que hacemos es crear otro objeto distinto, que de inmediato se descarta, ya que no se guarda en ninguna parte.
									Así, en los dos primeros objetos instanciados sus variables toman los valores predeterminados (null y false), y es el tercer objeto el único que se instancia con los valores introducidos.
								</p>
								<h4>Constructores que requieren los mismos parámetros, pero en distinto orden.</h4>
								<p>
									Siempre y cuando los parámetros estén en distinto orden. 
								</p>
								<h4>Otras características del constructor en Java.</h4>
								<p>
									Los constructores pueden ser...
									<ul>
										<li>public</li>
										<li>private</li>
										<li>protected</li>
									</ul>
									No pueden ser ...
									<ul>
										<li>static</li>
										<li>final</li>
										<li>abstract</li>
										<li>synchronized o native</li>
									</ul>								
								</p>
							</p> <!-- Qué diferencia hay entre un método y un constructor en Java -->
						</p>
						<!-- 1º Crear la receta -->
						<h2>Práctica: Cómo instanciar un objeto.</h2>
						<h3>1º Crea tu 'receta' o clase</h3>
						<p>
							<h4>Crea un archivo .java que contenga la clase.</h4>
							<p>
								Una clase <strong>Java</strong> no es más que un molde o receta con el vamos a crear un esquema del objeto que quieres instanciar. <br>
								Como nosotros vamos a crear una lámpara, vamos a crear el archivo <b>Lampara.java</b>
								<code>
									<pre>
/*
* Instanciar objetos
*/
package net.hc.instanciarobjetos;

/**
* @date 15 de mayo de 2022
* @version  0.1
* @author Paulino Esteban Bermúdez Rodríguez | humancomputing.net
*/
public class Lampara {
	// Esta es la 'receta' para crear lámparas.
}
class LamparaCreator{
	public static void main(String[] args) {
		// En esta otra voy a crear las lámparas        
	}
}									   
									</pre>
								</code>
								En este caso se ha creado dos clases, la que se va a instanciar (Lampara) y otra, LamparaCreator, desde la que se va a instanciar los objetos de tipo Lampara.
								Puede ejecutar la clase: complia con normalidad e instancia un objeto, pero no hace nada más.						
							</p> <!-- Crear archivo .java -->							
						</p><!-- 1º crea tu  receta  -->
						<h3>2º Define las características del objeto.</h3>
						<p>
							Vamos a crear lámparas que van a tener un color (ya sea el color que se introduzca al instanciar el objeto, o uno predeterminado) y que, por supuesto, se van a poder encender y apagar. <br>
							En este paso voy a hacer uso de la encapsulación: es decir, las variables van a ser privadas y se va a acceder a ellas a través de métodos que han sido creados con este fin.
							<code>
								<pre>
public class Lampara {
	private String color;
	private boolean encendida;
}
class LamparaCreator{
	public static void main(String[] args) {
		Lampara lampara = new Lampara();
	}
}									
								</pre>
							</code>
							De nuevo, la clase compila y se instancia el objeto. Pero ¿qué hacemos con las variables? Hay que inicializarlas creando nuestro propio constructor.
							<code>
								<pre>
public class Lampara {
	private String color;
	private boolean encendida;
	
	public Lampara(String color) {
		this.color = color;
	}
	public Lampara(){
		this("Azul");
	}
}
class LamparaCreator{
	public static void main(String[] args) {
		Lampara lampara = new Lampara();
	}
}									
								</pre>
							</code>
							Si se fija en el constructor, verá que, a la hora de instanciar, tenemos dos opciones. Por un lado, puede instanciar un objeto sin nigún parámetro. Esto quiere decir que uso el constructor que no admite parámetros 
							que, a su vez, ejecuta el segundo constructor con el parámetro predeterminado "Azul". Por otro lado, también puede instanciar un objeto de tipo Lampara usando el color que se quiere. <br>
							Además, verás que la variable  'encendida' se queda sin inicializar. Más adelante aprenderás el valor predeterminado de las variables de clase o instancia, en este caso, al ser un <i>boolean</i>, el valor predeterminado
							es false. Es decir, de manera predeterminada la lámpara está apagada.
						</p> <!-- 2º Características del objeto -->
						<h3>3º Instanciar un objeto no es toda la historia: ¿y si quieres modificarlo?</h3>
						<p>
							<h4>No hay que olvidarse de la encapsulación.</h4>
							<p>
								Verás que las variables que definen el color y el estado (encendida/apagada) de la lámpara son privadas. El siguiente paso para aplicar el encapsulamiento consiste en crear unos métodos para acceder o modificar estas variables. 
							</p>							
							<h4>¿En qué consiste el encapsulamiento?</h4>
							<p>
								<ul>
									<li>
										Limita el acceso a las variables, tanto de instancia como de clase (estáticas) mediante la palabra clave <strong>private</strong>.
									</li>
									<li>
										Crea métodos para acceder y/o modificar las variables. Por convención, el nombre del método que devuelve el valor de la variable comienza por get (o is si es una variable boolean); el nombre del método que establece un nuevo
										un nuevo valor comienza por set.
									</li>
								</ul>
								Quizá se pregunte por qué no se puede permitir el acceso directo a las variables. La respuesta es sencilla, si el acceso/modificación de las variables se realiza mediante un método, se puede controlar que el valor que se le vaya a asignar 
								a la variable sea un valor válido.
							</p>
							<h4>Un ejemplo gráfico de encapsulamiento.</h4>
							<p>
								Supón que el objeto es una vivienda, y tú no tienes la llave. No obstante, dentro de la vivienda hay personas que van a realizar su solicitud.
								Van a contestar a tus preguntas sobre el piso, y van a aceptar tus modificaciones, siempre y cuando se correspondan con un criterio predeterminado. Por ejemplo, no van a pintar las paredesdel piso de color negro, pero sí de azul celeste. 
								Si tú tuvieras acceso al piso, podrías hacer y deshacer sin control, y romper o estropear cosas. <br>
								En el caso del nuestro objetivo de tipo Lampara, el color de la lámpara no se va a poder modificar una vez instanciada, pero só se va a poder encender y apagar. 
								<code>
									<pre>
public class Lampara {
	private String color;
	private boolean encendida;
	/**
		* El objeto de tipo Lampara puede instanciarse con un color elegido al 
		* instanciarlo, o con el color "Azul" predeterminado.
		* @param color 
		*/
	public Lampara(String color) {
		this.color = color;
	}
	public Lampara(){
		this("Azul");
	}
	public String getColor() {
		return color;
	}
	/**
		* Asigna a encendida el valor contrario al que posee
		*/
	public void interruptor(){
		encendida = !encendida;
		System.out.println("Lámpara: " + encendida);
	}
	public boolean isEncendida() {
		return encendida;
	}
}
class LamparaCreator{
	public static void main(String[] args) {
		Lampara lampara = new Lampara();
		System.out.println(lampara.getColor() + " " + lampara.isEncendida()); // Azul y false
		lampara.interruptor();
		System.out.println(lampara.getColor() + " " + lampara.isEncendida()); // Azul y true
		System.out.println(lampara); //Ubicacion en memoria del PC de Lampara
	}
}										
									</pre>
								</code>
								Como ves, se agregó unas líneas más de código en el método <b>main</b> de la clase <b>LamparaCreator</b> para no solo instanciar un objeto, sino también para comprobar el color de la lámpara, para comprobar si está encendida o apagada y para 
								cambiarle este último estado. <br>
								En un inicio la lámpara está apagada (false); la segunda línea muestra el cambio de estado  y, al volver a imprimir el estado de la lámpara, vemos que está encendida (true). <br>
								La última línea es el resultado de imprimir el objeto utilizando <strong>System.out.println(lampara);</strong>
							</p>
							<strong>Imprime el objeto que has instanciado</strong>.
							<p>
								Más adelante se hablará con más detalle de la herencia y del método <b>toString()</b>. <br>
								Todos los objetos heredan de manera implícita de la clase Object, y heredan una serie de métodos de esta. Uno de ellos, el que voy a usar ahora, es <b>toString()</b>. <br>
								Puedes ejecutar este método directamente, o de manera implícita, imprimiendo un objeto. Como has visto en el ejemplo anterior, si usas directamente el método que tu clase hereda de la clase Object (sin implicitar tu propia version de toString()), 
								el resultado es poco intuitivo. Es por ello que es recomendable que implementes tu propia versión. <br>
								<code>
									<pre> <i>
@Override
public String toString() {
	String onOff = encendida ? "ON" : "OFF";
		return "La lámpara es " + color + " y está " + onOff;
} </i>
									</pre>
								</code>
								Queda como resultado:
								<code>
									<pre>
/*
* Instanciar objetos
*/
package net.hc.instanciarobjetos;
/**
* @date 15 de mayo de 2022
* @version  0.1
* @author Paulino Esteban Bermúdez Rodríguez | humancomputing.net
*/
public class Lampara {
	private String color;
	private boolean encendida;
	/**
	* El objeto de tipo Lampara puede instanciarse con un color elegido al 
	* instanciarlo, o con el color "Azul" predeterminado.
	* @param color 
	*/
	public Lampara(String color) {
		this.color = color;
	}
	public Lampara(){
		this("Azul");
	}
	public String getColor() {
		return color;
	}
	/**
	* Asigna a encendida el valor contrario al que posee
	*/
	public void interruptor(){
		encendida = !encendida;
		System.out.println("Lámpara: " + encendida);
	}
	public boolean isEncendida() {
		return encendida;
	}
	@Override
	public String toString() {
		String oN_Off = encendida ? "ON":"OFF";
		return "La lámpara es " + color + " y está " + oN_Off;
	}
}
class LamparaCreator{
	public static void main(String[] args) {
		Lampara lampara = new Lampara();
		System.out.println(lampara.getColor() + " " + lampara.isEncendida()); // Azul y false
		lampara.interruptor();
		System.out.println(lampara.getColor() + " " + lampara.isEncendida()); // Azul y true
		System.out.println(lampara); // Ubicacion en memoria del PC de Lampara
	}
}
									</pre>
								</code>
							</p>
						</p>
					</p> <!-- parrafo principal-->
				</div>
			</div>					
		<footer id="contact">
			<div class="container">
				<div class="row">
					<div class="col-md-4 footer-leftcol">
						<p><span class="bold-16p"><a href="https://humancomputing.net" target="_blank" rel="noopener noreferrer">Human Computig</a></span><br>
						Extremadura, España<br>
						Navalmoral de la Mata. <a href="mailto:paulino@humancomputing.net">paulino@humancomputing.net</a>
						</p>
					</div>
					<div class="col-md-4 footer-midcol">
						<ul>
							<li><a href="#" class="twitter-icon">Twitter</a></li>
							<li><a href="#" class="facebook-icon">Facebook</a></li>
							<li><a href="#" class="pintrest-icon">Pintrest</a></li>
						</ul>
						<div class="clearfix"></div>
					</div>
					<div class="col-md-4 footer-rightcol">
						<p>Designed by ♥️</p>
						<p class="nopadding">Developed by <a href="http://designscrazed.org/">Peter</a>,
						Written by <a href="https://humancomputing.net">Steve</a><p>
					</div>
				</div>
			</div>
		</footer>
		<!-- jQuery (necessary for Bootstrap's JavaScript plugins)-->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
		<!-- Include all compiled plugins (below), or include individual files as needed -->
		<script src="../js/bootstrap.min.js"></script>
		<script src="../js/jquery.flexslider.js"></script>
		<script src="../js/scripts.js"></script>
		<script src="../js/modernizr.js"></script>
		<script src="../js/waypoints.min.js"></script>
	</body>
</html>